*****Первоначальная настройка Git
Теперь, когда Git установлен в вашей системе, самое время настроить
среду для работы с Git’ом под себя. Это нужно сделать только один
раз  — при  обновлении  версии Git’а  настройки  сохранятся. Но, при
необходимости, вы можете поменять их в любой момент, выполнив те
же команды снова.
В  состав Git’а  входит  утилита  git config, которая  позволяет
просматривать  и  настраивать  параметры, контролирующие  все
аспекты работы Git’а, а также его внешний вид. Эти параметры могут
быть сохранены в трёх местах:
	1. Файл  /etc/gitconfig содержит  значения, общие  для  всех
пользователей  системы  и  для  всех  их  репозиториев. Если  при
запуске  git config указать  параметр  --system, то  параметры
будут читаться и сохраняться именно в этот файл.
	2. Файл ~/.gitconfig или ~/.config/git/config хранит настройки
конкретного  пользователя. Этот  файл  используется  при
указании параметра --global.
	3. Файл  config в  каталоге Git’а  (т.е. .git/config) в  том
репозитории, который вы используете в данный момент, хранит
настройки конкретного репозитория.
Настройки на каждом следующем уровне подменяют настройки из
предыдущих  уровней, то  есть  значения  в  .git/config перекрывают
соответствующие значения в /etc/gitconfig.
	В  системах  семейства Windows Git ищет  файл  .gitconfig в
каталоге  $HOME (C:\Users\$USER для  большинства  пользователей).
Кроме  того Git ищет  файл  /etc/gitconfig, но  уже  относительно
корневого  каталога MSys, который  находится  там, куда  вы  решили
установить Git, когда запускали инсталлятор.
*****

*****Ввод первоначальных ланных пользователя (Git Bash)
$ git config --global user.name "Ruslanito"
$ git config --global user.email breitovo76@gmail
*****

*****Проверка настроек Git (Git Bash)
$ git config --list

core.symlinks=false
core.autocrlf=true
core.fscache=true
color.diff=auto
color.status=auto
color.branch=auto
color.interactive=true
help.format=html
http.sslcainfo=C:/Program Files/Git/mingw64/ssl/certs/ca-bundle.crt
diff.astextplain.textconv=astextplain
rebase.autosquash=true
credential.helper=manager
filter.lfs.clean=git-lfs clean -- %f
filter.lfs.smudge=git-lfs smudge -- %f
filter.lfs.required=true
user.name=Ruslanito
user.email=breitovo76@gmail.com

	Некоторые  ключи  (названия) настроек  могут  появиться  несколько
раз, потому  что Git читает  один  и  тот  же  ключ  из  разных  файлов
(например  из  /etc/gitconfig и  ~/.gitconfig). В  этом  случае Git
использует последнее значение для каждого ключа.
	Также  вы  можете  проверить  значение  конкретного  ключа,
выполнив git config <key>:
$ git config user.name
Ruslanito
*****

*****Получение помощи
	Если  вам  нужна  помощь  при  использовании Git, есть  три  способа
открыть страницу руководства по любой команде Git:
	1. $ git help <verb>
	2. $ git <verb> --help
	3. $ man git-<verb>
Например, так можно открыть руководство по команде config 
       $ git help config
Эти  команды  хороши  тем, что  ими  можно  пользоваться  всегда,
даже  без  подключения  к  сети. Если  руководства  и  этой  книги
недостаточно  и  вам  нужна  персональная  помощь, вы  можете
попытаться поискать её на каналах #git и #github сервера Freenode
IRC (irc.freenode.net). Обычно  там  сотни  людей, отлично  знающих Git,
которые могут помочь.
*****

*****Создание Git-репозитория
	Для создания Git-репозитория вы можете использовать два основных
подхода. Во-первых, импорт  в Git уже  существующего  проекта  или
директории. Во-вторых, клонирование существующего репозитория с
другого сервера

*	Создание репозитория в существующей директории
Если  вы  собираетесь  начать  использовать Git для  существующего
проекта, то  вам  необходимо  перейти  в  директорию  проекта  и  в
командной строке ввести (в контекстном меню запустить Git Bash Here):
		$ git init
	Эта команда создаёт в текущей директории новую поддиректорию
с именем .git, содержащую все необходимые файлы репозитория —
основу Git-репозитория. На этом этапе ваш проект ещё не находится
под  версионным  контролем.
	Если вы хотите добавить под версионный контроль существующие
файлы  (в  отличие  от  пустого  каталога), вам  стоит  добавить  их  в
индекс и осуществить первый коммит изменений. Добиться этого вы
сможете  запустив  команду  git add несколько  раз, указав
индексируемые файлы, а затем выполнив git commit:
	$ git add *.c
	$ git add LICENSE
	$ git commit -m 'initial project version'
Мы разберем, что делают эти команды чуть позже. Теперь у вас
есть Git-репозиторий  с  отслеживаемыми  файлами  и  начальным
коммитом.
 
*	Клонирование существующего репозитория
Для  получения  копии  существующего Git-репозитория, например,
проекта, в  который  вы  хотите  внести  свой  вклад, необходимо
использовать  команду  git clone. Если  вы  знакомы  с  другими
системами  контроля  версий, такими  как Subversion, то  заметите, что
команда  называется  “clone”, а  не  “checkout”. Это  важное  различие  –
вместо  того, чтобы  просто  получить  рабочую  копию, Git получает
копию  практически  всех  данных, которые  есть  на  сервере. При
выполнении  git clone с  сервера  забирается  (pulled) каждая  версия
каждого файла из истории проекта. Фактически, если серверный диск
выйдет из строя, вы можете использовать любой из клонов на любом
из  клиентов, для  того, чтобы  вернуть  сервер  в  то  состояние, в
котором он находился в момент клонирования (вы можете потерять
часть  серверных  перехватчиков  (server-side hooks) и  т.п., но  все
данные, помещённые  под  версионный  контроль, будут  сохранены,
подробнее об этом смотрите в главе “Установка Git на сервер”).
Клонирование  репозитория  осуществляется  командой:
	$ git clone [url]
Например, если  вы  хотите  клонировать  библиотеку libgit2, вы
можете сделать это следующим образом:
	$ git clone https://github.com/libgit2/libgit2
Эта  команда  создаёт  директорию  “libgit2”, инициализирует  в  ней
поддиректорию .git, скачивает все данные для этого репозитория и
создаёт  (checks out) рабочую  копию  последней  версии. Если  вы
зайдёте  в  новую  директорию  libgit2, то  увидите  в  ней  файлы
проекта, готовые  для  работы  или  использования. Для  того, чтобы
клонировать репозиторий в директорию с именем, отличающимся от
“libgit2”, необходимо указать желаемое имя, как параметр командной
строки:
	$ git clone https://github.com/libgit2/libgit2 mylibgit
Эта  команда  делает  всё  то  же  самое, что  и  предыдущая, только
результирующий каталог будет назван mylibgit.
В Git’е  реализовано  несколько  транспортных  протоколов, которые
вы  можете  использовать. В  предыдущем  примере  использовался
протокол  https://, вы  также  можете  встретить  git:// или
user@server:path/to/repo.git, использующий  протокол  передачи
SSH. В  главе  “Установка Git на  сервер” мы  познакомимся  со  всеми
доступными  вариантами  конфигурации  сервера  для  обеспечения
доступа  к  вашему Git-репозиторию, а  также  рассмотрим  их
достоинства и недостатки.

*	Запись изменений в репозиторий
	Итак, у  вас  имеется  настоящий Git-репозиторий  и  рабочая  копия
файлов  для  некоторого  проекта. Вам  нужно  делать  некоторые
изменения  и  фиксировать  “снимки” состояния  (snapshots) этих
изменений в вашем репозитории каждый раз, когда проект достигает
состояния, которое вам хотелось бы сохранить.
	Запомните, каждый  файл  в  вашем  рабочем  каталоге  может
находиться  в  одном  из  двух  состояний: под  версионным  контролем
(отслеживаемые) и  нет  (неотслеживаемые). Отслеживаемые  файлы
— это  те  файлы, которые  были  в  последнем  слепке  состояния
проекта (snapshot); они могут быть неизменёнными, изменёнными или
подготовленными к коммиту (staged). Неотслеживаемые файлы — это
всё остальное, любые файлы в вашем рабочем каталоге, которые не
входили  в  ваш  последний  слепок  состояния  и  не  подготовлены  к
коммиту. Когда  вы  впервые  клонируете  репозиторий, все  файлы
будут  отслеживаемыми  и  неизменёнными, потому  что  вы  только
взяли  их  из  хранилища  (checked them out) и  ничего  пока  не
редактировали.
	Как только вы отредактируете файлы, Git будет рассматривать их
как изменённые, т.к. вы изменили их с момента последнего коммита.
Вы  индексируете  (stage) эти  изменения  и  затем  фиксируете  все
индексированные изменения, а затем цикл повторяется.

*	Определение состояния файлов
	Основной инструмент, используемый для определения, какие файлы
в  каком  состоянии  находятся  — это  команда:
		$ git status. Если  вы
выполните эту команду сразу после клонирования, вы увидите что-то
вроде этого:
		$ git status
	On branch master
	nothing to commit, working directory clean
Это означает, что у вас чистый рабочий каталог, другими словами
– в  нем  нет  отслеживаемых  измененных  файлов. Git также  не
обнаружил  неотслеживаемых  файлов, в  противном  случае  они  бы
были перечислены здесь. Наконец, команда сообщает вам на какой
ветке вы находитесь и сообщает вам, что она не расходится с веткой
на  сервере. Пока  что  это  всегда  ветка ``master``, ветка  по
умолчанию; в этой главе это не важно.	
	Предположим, вы  добавили  в  свой  проект  новый  файл, простой
файл README. Eсли этого файла раньше не было, и вы выполните git
status, вы увидите свой неотслеживаемый файл вот так:
		$ echo 'My Project' > README
		$ git status
	On branch master
	Untracked files:
  (use "git add <file>..." to include in what will be committed)
    README
	nothing added to commit but untracked files present (use "git add" to track)
Понять, что новый файл README неотслеживаемый можно по тому,
что он находится в секции ``Untracked files`` в выводе команды ``sta-
tus``. Статус ``Untracked files``, по сути, означает, что Git видит файл,
отсутствующий  в  предыдущем  снимке  состояния  (коммите); Git не
станет добавлять его в ваши коммиты, пока вы его явно об этом не
попросите. Это  предохранит  вас  от  случайного  добавления  в
репозиторий  сгенерированных  бинарных  файлов  или  каких-либо
других, которые вы и не думали добавлять. Мы хотели добавить RE-
ADME, так давайте сделаем это.

*	Отслеживание новых файлов
Для  того  чтобы  начать  отслеживать  (добавить  под  версионный
контроль) новый файл, используется команда^
		$ git add
Чтобы начать отслеживание файла README, вы можете выполнить следующее:
		$ git add README
Если вы снова выполните команду status, то увидите, что файл RE-
ADME теперь отслеживаемый и индексированный:
		$ git status
	On branch master
	Changes to be committed:
	(use "git reset HEAD <file>..." to unstage)
    new file:   README
Вы  можете  видеть, что  файл  проиндексирован  по  тому, что  он
находится в секции ``Changes to be committed``. Если вы выполните
коммит в этот момент, то версия файла, существовавшая на момент
выполнения  вами  команды  git add, будет  добавлена  в  историю
снимков состояния. Как вы помните, когда вы ранее выполнили git
init, затем вы выполнили git add (файлы) — это было сделано для
того, чтобы  добавить  файлы  в  вашем  каталоге  под  версионный
контроль. Команда git add принимает параметром путь к файлу или
каталогу, если  это  каталог, команда  рекурсивно  добавляет
(индексирует) все файлы в данном каталоге.

* Индексация изменённых файлов



